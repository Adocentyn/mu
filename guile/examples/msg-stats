#!/bin/sh
exec guile -e main -s $0 $@
!#

;;
;; Copyright (C) 2011 Dirk-Jan C. Binnema <djcb@djcbsoftware.nl>
;;
;; This program is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the
;; Free Software Foundation; either version 3, or (at your option) any
;; later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;

;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software Foundation,
;; Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

(use-modules (ice-9 getopt-long) (ice-9 optargs) (ice-9 popen) (ice-9 format))
(use-modules (mu) (mu message))

;; note, this is a rather inefficient way to calculate the number; for
;; demonstration purposes only...
;; (define* (count #:optional (EXPR ""))
;;   "Count the total number of messages. If the optional EXPR is
;; provided, only count the messages that match it.\n"
;;   (for-each-message (lambda(msg) #f) EXPR))

;; (define* (average FUNC #:optional (EXPR ""))
;;   "Count the average of the result of applying FUNC on all
;; messages. If the optional EXPR is provided, only consider the messages
;; that match it.\n"
;;   (let* ((sum 0)
;; 	  (n (for-each-message
;; 	       (lambda(msg) (set! sum (+ sum (FUNC msg)))) EXPR)))
;;     (if (= n 0) 0 (exact->inexact (/ sum n)))))

;; (define* (average-size #:optional (EXPR ""))
;;   "Calculate the average message size. If the optional EXPR is
;; provided, only consider the messages that match it.\n"
;;   (average (lambda(msg) (mu:msg:size msg)) EXPR))

;; (define* (average-recipient-number #:optional (EXPR ""))
;;   "Calculate the average number of recipients (To: + CC: + Bcc:). If
;; the optional EXPR is provided, only consider the messages that match
;; it.\n"
;;   (average (lambda(msg)
;; 		      (+(length (mu:msg:to msg))
;; 			(length (mu:msg:cc msg))
;; 			(length (mu:msg:bcc msg)))) EXPR))

;; (define* (frequency FUNC #:optional (EXPR ""))
;;   "FUNC is a function that takes a msg, and returns the frequency of
;; the different values this function returns. If FUNC returns a list,
;; update the frequency table for each element of this list. If the
;; optional EXPR is provided, only consider messages that match it.\n"
;;   (let ((table '()))
;;     (mu:for-each-message
;;       (lambda(msg)
;; 	;; note, if val is not already a list, turn it into a list
;; 	;; then, take frequency for each element in the list
;; 	(let* ((val (FUNC msg)) (vals (if (list? val) val (list val))))
;; 	  (for-each
;; 	    (lambda (val)
;; 	      (let ((freq (assoc-ref table val)))
;; 		(set! table (assoc-set! table val
;; 			      (+ 1 (if (eq? freq #f) 0 freq)))))) vals))) EXPR)
;;     table))


(define* (per-weekday #:optional (EXPR ""))
  "Count the total number of messages for each weekday (0-6 for
Sun..Sat). If the optional EXPR is provided, only count the messages
that match it. The result is a list of pairs (weekday . frequency).\n"
  (let* ((stats (mu:tabulate-messages
		  (lambda (msg) (tm:wday (localtime (date msg)))) EXPR)))
    (sort stats (lambda(a b) (< (car a) (car b)))))) ;; in order of weekday

(define* (mu:plot:per-weekday #:optional (EXPR ""))
  (let* ((datafile (export-pairs (per-weekday EXPR)))
	  (gnuplot (open-pipe "gnuplot -p" OPEN_WRITE)))
    ;; note, we cannot use the weekday "%a" support in gnuplot because
    ;; demands the field to be a date field ('set xdata time' etc.)
    ;; for that to work, but we cannot use that since gnuplot does not
    ;; support weekdays ('%w') as a date field in its input
    (display (string-append
	       "reset\n"
	       "set xtics (\"Sun\" 0, \"Mon\" 1, \"Tue\" 2, \"Wed\" 3,"
	                  "\"Thu\" 4, \"Fri\" 5, \"Sat\" 6);\n"
	       "set xlabel \"Weekday\"\n"
	       "set ylabel \"# of messages\"\n"
	       "set boxwidth 0.9\n") gnuplot)
    (display (string-append "plot \"" datafile "\" using 1:2 with boxes fs solid\n")
      gnuplot)
    (close-pipe gnuplot)))


(define* (per-month #:optional (EXPR ""))
  "Count the total number of messages for each month (1-12 for
Jan..Dec). If the optional EXPR is provided, only count the messages
that match it. The result is a list of pairs (month . frequency).\n"
  (let* ((stats (mu:tabulate-messages
		  (lambda (msg) ;; note the 1+
		    (1+ (tm:mon (localtime (date msg))))) EXPR)))
    (sort stats
      (lambda(a b)
	(< (car a) (car b)))))) ;; in order ofmonth


(define* (mu:plot:per-month #:optional (EXPR ""))
  (let* ((datafile (export-pairs (per-month EXPR)))
	  (gnuplot (open-pipe "gnuplot -p" OPEN_WRITE)))
    (display (string-append
	       "reset\n"
	       "set xtics (\"Jan\" 1, \"Feb\" 2, \"Mar\" 3, \"Apr\" 4,"
	                  "\"May\" 5, \"Jun\" 6, \"Jul\" 7, \"Aug\" 8,"
	                  "\"Sep\" 9, \"Oct\" 10, \"Nov\" 11, \"Dec\" 12);\n"
	       "set xlabel \"Month\"\n"
	       "set ylabel \"# of messages\"\n"
	       "set boxwidth 0.9\n") gnuplot)
    (display (string-append "plot \"" datafile "\" using 1:2 with boxes fs solid\n")
      gnuplot)
    (close-pipe gnuplot)))


(define* (per-hour #:optional (EXPR ""))
  "Count the total number of messages for each weekday (0-6 for
Sun..Sat). If the optional EXPR is provided, only count the messages
that match it. The result is a list of pairs (weekday . frequency).\n"
  (let* ((stats (mu:tabulate-messages
		  (lambda (msg) (tm:hour (localtime (date msg)))) EXPR)))
    (sort stats (lambda(a b) (< (car a) (car b)))))) ;; in order of hour

(define* (mu:plot:per-hour #:optional (EXPR ""))
  (let* ((datafile (export-pairs (per-hour EXPR)))
	  (gnuplot (open-pipe "gnuplot -p" OPEN_WRITE)))
    (display (string-append
	       "reset\n"
	       "set xlabel \"Hour\"\n"
	       "set ylabel \"# of messages\"\n"
	       "set boxwidth 0.9\n") gnuplot)
    (display (string-append "plot \"" datafile "\" using 1:2 with boxes fs solid\n")
      gnuplot)
    (close-pipe gnuplot)))


(define* (per-year #:optional (EXPR ""))
  "Count the total number of messages for each year since 1970. If the
optional EXPR is provided, only count the messages that match it. The
result is a list of pairs (year . frequency).\n"
  (let* ((stats (mu:tabulate-messages
		  (lambda (msg) (+ 1900 (tm:year (localtime (date msg)))))
		  EXPR)))
    (sort stats (lambda(a b) (< (car a) (car b)))))) ;; in order of year

(define* (mu:plot:per-year #:optional (EXPR ""))
  (let* ((datafile (export-pairs (per-year EXPR)))
	  (gnuplot (open-pipe "gnuplot -p" OPEN_WRITE)))
    (display (string-append
	       "reset\n"
	       "set xlabel \"Year\"\n"
	       "set ylabel \"# of messages\"\n"
	       "set boxwidth 0.9\n") gnuplot)
    (display (string-append "plot \"" datafile "\" using 1:2 with boxes fs solid\n")
      gnuplot)
    (close-pipe gnuplot)))

;; (define* (top-n FUNC N #:optional (EXPR ""))
;;   "Get the Top-N frequency of the result of FUNC applied on each
;; message. If the optional EXPR is provided, only consider the messages
;; that match it."
;;   (let* ((freq (frequency FUNC EXPR))
;; 	  (top (sort freq (lambda (a b) (< (cdr b) (cdr a) )))))
;;     (list-head top (min (length freq) N))))

;; (define* (top-n-to #:optional (N 10) (EXPR ""))
;;   "Get the Top-N To:-recipients. If the optional N is not provided,
;; use 10. If the optional EXPR is provided, only consider the messages
;; that match it."
;;   (top-n
;;     (lambda (msg) (mu:msg:to msg)) N EXPR))

;; (define* (top-n-from #:optional (N 10) (EXPR ""))
;;   "Get the Top-N senders (From:). If the optional N is not provided,
;; use 10. If the optional EXPR is provided, only consider the messages
;; that match it."
;;   (top-n
;;     (lambda (msg) (mu:msg:from msg)) N EXPR))

;; (define* (top-n-subject #:optional (N 10) (EXPR ""))
;;   "Get the Top-N subjects. If the optional N is not provided,
;; use 10. If the optional EXPR is provided, only consider the messages
;; that match it."
;;   (top-n
;;     (lambda (msg) (mu:msg:subject msg)) N EXPR))

(define* (table pairs #:optional (port (current-output-port)))
  "Display a list of PAIRS in a table-like fashion."
  (let ((maxlen 0))
    (for-each ;; find the widest in the first col
      (lambda (pair)
	(set! maxlen
	  (max maxlen (string-length (format #f "~s " (car pair)))))) pairs)
    (for-each
      (lambda (pair)
	(let ((first (format #f "~s" (car pair)))
	       (second (format #f "~s" (cdr pair))))
	  (display (format #f "~A~v_~A\n"
		     first (- maxlen (string-length first)) second) port)))
      pairs)))

;; (define* (histogram pairs #:optional (port (current-output-port)))
;;   "Display a histogram of the list of cons pairs; the car of each pair
;; is used for the x-asxis, while the cdr represents the y value."
;;   (let ((pairs ;; pairs may be unsorted, so let's sort first
;; 	  (sort (pairs) (lambda(x1 x2) (< x1 x2)))))

(define (export-pairs pairs)
  "Export PAIRS to a temporary file, return its name. The data can
then be used in, e.g., R and gnuplot."
  (let* ((datafile (tmpnam))
	  (output (open datafile (logior O_CREAT O_WRONLY) #O0644)))
    (table pairs output)
    (close output)
    datafile))

(define (main args)
  (let* ((optionspec   '( (muhome  (value #t))
			  (period  (value #t))
			  (help    (single-char #\h) (value #f))))
	  (options (getopt-long args optionspec))
	  (msg (string-append
		 "usage: mu-msg-stats [--help] [--muhome=<muhome>] "
		 "--period=<hour|day|month|year> [searchexpr]\n"))
	  (help (option-ref options 'help #f))
	  (period (option-ref options 'period #f))
	  (muhome (option-ref options 'muhome #f))
	  (restargs (option-ref options '() #f))
	  (expr (if restargs (string-join restargs) "")))
    (if (or help (not period))
      (begin
	(display msg)
	(exit (if help 0 1))))
    (mu:initialize muhome)
    (cond
      ((string= period "hour")  (mu:plot:per-hour expr))
      ((string= period "day")   (mu:plot:per-weekday expr))
      ((string= period "month") (mu:plot:per-month expr))
      ((string= period "year")  (mu:plot:per-year expr))
      (else (begin
	      (display msg)
	      (exit 1))))))

;; Local Variables:
;; mode: scheme
;; End:
